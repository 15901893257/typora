## 1.并发事务带来的问题

- 更新丢失：当两个或者多个事务更新同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题—最后的更新覆盖了由其他事务所做的更新。
- 脏读：一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”数据，并据此做进一步的处理，就会产生未提交的数据依赖关系，这种现象被称为“脏读”
- 不可重复读：一个事务在读取某些数据后的某个时间，再次读取之前读过的数据，却发现其读出的数据已经发生了改变、或者某些记录已经被删除了。这种现象被称为“不可重复读”
- 幻读：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象被称为“幻读”

### **1.1 不可重复读和幻读的区别**

**不可重复读重点在于update，而幻读的重点在于insert和delete。**

如果使用锁机制来实现这两种隔离级别，在可重复读中，该sql第一次读取到数据后，就将这些数据加锁，其它事务无法修改这些数据，就可以实现可重复 读了。但这种方法却无法锁住insert的数据，所以当事务A先前读取了数据，或者修改了全部数据，事务B还是可以insert数据提交，这时事务A就会 发现莫名其妙多了一条之前没有的数据，这就是幻读，不能通过行锁来避免。需要Serializable隔离级别 ，读用读锁，写用写锁，读锁和写锁互斥，这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力。

## 2.事务隔离级别

| 隔离级别                     | 含义                                               | 读数据一致性                             | 脏读 | 不可重复读 | 幻读 |
| :--------------------------- | :------------------------------------------------- | :--------------------------------------- | :--- | :--------- | :--- |
| 读未提交（Read Uncommitted） | 事务中的修改，即使没有提交，对其他事务都是可见的   | 最低级别，只能保证不读取物理上损坏的数据 | 是   | 是         | 是   |
| 读已提交（Read Committed）   | 事务从开始到提交之前，所做的修改对其他事务都不可见 | 语句级                                   | 否   | 是         | 是   |
| 可重复读（Repeatable read）  | 同一事务中多次读取同样的记录结果是一致的           | 事务级                                   | 否   | 否         | 是   |
| 可序列化（Serializable）     | 在读取的每一行数据上加锁，强制事务串行执行         | 最高级别，事务级                         | 否   | 否         | 否   |

 **InnoDB默认隔离级别是RR,InnoDB通过next_key_lock和mvcc避免幻读**

## 3.事务隔离实现

数据库实现事务隔离的方式，基本上分为以下两种：

- 加锁：读取数据之前，对其加锁，阻止其他事务对数据进行修改
- MVCC：不加任何锁，采用多版本并发控制实现。MVCC使得大部分支持行锁的事务引擎不再单纯的使用行锁来进行数据库的并发控制，而是把数据库的行锁和行的多个版本结合起来，可以实现非锁定读，从而提高数据库的并发性能。

### 3.1 数据加锁

MySQL锁设计的目的是为了处理并发问题，合理控制资源访问。

**InnoDB三种不同类型的锁**

#### 3.1.1 自增锁Auto-inc Locks

是特殊的**表级别锁**，专门针对事务插入**AUTO_INCREMENT**类型的列。

原理：每张表自增长值并不保存在磁盘上进行持久化，而是每次InnoDB存储引擎启动时，执行以下操作：

```sql
SELECT MAX(auto_inc_col) FROM T FOR UPDATE;
```

之后得到的值会用变量**auto_inc_lock**作缓存，插入操作会根据这个自增长值加1赋予自增长列。因为每张表只有同一时刻只能有一个自增锁，可以避免同一表锁对象在各个事务中不断地被申请。

**自增主键是否一定是连续的呢？**

这里我们可以做个实验，假设Test表有主键id和唯一索引列a，已经有了(1,1)这条记录

1.先插入一行(null,1)

2.InnoDB发现用户没有指定自增id，获取当前自增值2

3.将传入的值改成(2,1)

4.将表自增id改成3

5.继续执行插入(2,1)，由于已经存在a=1，所以报Duplicate key error

![image-20200701160032928](/Users/dengquanliang/Library/Application%20Support/typora-user-images/image-20200701160032928.png)

自增主键不连续复现步骤：

<img src="/Users/dengquanliang/Library/Application%20Support/typora-user-images/image-20200701160234214.png" alt="image-20200701160234214" style="zoom: 50%;" />

<font color = red>**事务回滚或者特殊的批量插入语句insert...select也有可能出现这种情况**。</font>

为了提高插入的性能，在MySQL5.1版本之后，对于普通的insert语句，自增锁每次申请完马上释放，不是在一个事务完成后才释放，以便允许别的事务再次申请。

举个例子：假设Test表有主键id和唯一索引列a，有两个并行事务A和B，为了避免两个事务申请到相同的主键id，必须要加自增锁顺序申请

| 事务A                                  | 事务B                                                        |
| :------------------------------------- | :----------------------------------------------------------- |
| begin;insert into Test values(null,1); |                                                              |
|                                        | begin;insert into Test values(null,2);commit;//插入的行(2,2) |
| commit;                                |                                                              |

 事务A申请到主键id=1之后释放自增锁，没有等事务A提交之后释放，所以事务B可以插入不被阻塞。

#### 3.1.2 共享/排他锁shared and exclusive locks

共享和排他都是锁标准行级锁

- 共享锁(S)：事务拿到某一行记录共享S锁，才能读取。可以提高读读并发。
  - SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE
- 排他锁(X)：事务拿到某一行记录排他X锁，修改或者删除。用来保证数据强一致。
  - SELECT * FROM table_name WHERE ... FOR UPDATE

共享锁之间兼容，排它锁与任何锁都不兼容

#### 3.1.3 意向锁Intention Locks

意向锁是指未来某个时刻，事务要加共享/排他锁了，提前声明个意向。

- 意向共享锁(IS)：事务有意向对表中某几行加S锁
- 意向排他锁(IX)：事务有意向对表中某几行加X锁

意向锁协议：

- 事务要获得某些行的S锁，必须先获得表的IS锁
- 事务要获得某些行的X锁，必须先获得表的IX锁

自增锁、意向锁和行级锁的兼容性如下：

|        | AI     | IS     | IX     | S      | X      |
| :----- | :----- | :----- | :----- | :----- | :----- |
| **AI** | 不兼容 | 兼容   | 兼容   | 不兼容 | 不兼容 |
| **IS** | 兼容   | 兼容   | 兼容   | 兼容   | 不兼容 |
| **IX** | 兼容   | 兼容   | 兼容   | 不兼容 | 不兼容 |
| **S**  | 不兼容 | 兼容   | 不兼容 | 兼容   | 不兼容 |
| **X**  | 不兼容 | 不兼容 | 不兼容 | 不兼容 | 不兼容 |

###  3.2 InnoDB锁算法

#### 3.2.1 记录锁Record Locks

单个行记录上的锁，用来封锁索引记录。

如：假设Test表有主键id和唯一索引列a，已经有了(1,1)这条记录，执行select * from Test where id=1 for update；

会在id=1的索引记录上加锁，以阻止其他事物插入更新、删除id=1这一行。

#### 3.2.2 间隙锁Gap Locks

锁定一个范围，但不包含记录本身。

封锁索引记录中的间隙，确保索引记录的间隙不变。间隙锁是针对事务隔离级别为可重复读(RR)或以上级别而已的，如果隔离级别降级为读提交(RC)，间隙锁会自动失效。

幻读是如何产生的？

幻读是指一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没看到的行，具体例子如下：

```
CREATE TABLE `Test` (
  `id` int(11) NOT NULL,
  `a` int(11) DEFAULT NULL,
  `b` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `a` (`a`)
) ENGINE=InnoDB;

insert into t values(0,0,5),(5,5,5),(10,10,10);
```

如果只在 id=5 这一行加锁，而其他行的不加锁的话，就会发生以下情况

| 事务A                                                        | 事务B                           | 事务C                          |
| :----------------------------------------------------------- | :------------------------------ | :----------------------------- |
| begin;select * from Test where a=5 for update/*Q1*/result:(5,5,5) |                                 |                                |
|                                                              | update Test set a=5 where id=0; |                                |
| select * from Test where a=5 for update/*Q2*/result:(0,5,5)(5,5,5) |                                 |                                |
|                                                              |                                 | inset into Test values(1,5,5); |
| select * from Test where a=5 for update/*Q3*/result:(0,5,5)(1,5,5)(5,5,5) |                                 |                                |
| commit;                                                      |                                 |                                |

 Q3读到了id=1这一行，就叫“幻读”。

比如继续使用上面例子的表，执行select * from Test where b=5 for update时候，由于b没有索引，就会在插入3个记录锁，和4个间隙锁（关于加锁规则会在最后有更多案例说明），这样就确保了无法再插入新的记录，以此防止幻读的发生，如下图:

 ![image-20200701184209174](mysql%E9%94%81%E6%9C%BA%E5%88%B6.assets/image-20200701184209174.png)

间隙锁在往间隙中插入一个记录才会冲突，间隙锁之间不存在冲突关系。

> 1.for update产生gap lock，导致(max（id）, +∞)锁住，程序bug导致事务未提交，产生了946s的大事务**，**导致大量的insert产生lock wait；
>
> 2.代码bug，RD在staging环境连接线上主库进行操作，select一个不存在的大ID导致gap锁定，无法写入
>
> 解决：1.kill持有gap锁的连接；
>
> 2.无法kill则重启数据库，程序务必保证事务的闭合。

#### 3.2.3 临键锁Next-key Locks

**左开右闭原则**

临键锁是记录锁与间隙锁的组合。

为了避免幻读，当InnoDB扫描索引记录的时候，会首先对索引记录加上行锁（Record Lock），再对索引记录两边的间隙加上间隙锁（Gap Lock）

#### 3.2.4 **插入意向锁**Insert Intention Locks

**是间隙锁的一种，专门针对insert操作**。同一个索引，同一个范围区间插入记录，插入的位置不冲突，不会阻塞彼此，可以提高插入并发。

插入意向锁经常和间隙锁引发死锁问题，死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。

简单模拟一个死锁的场景：

| 事务A                                   | **事务B**                         |
| :-------------------------------------- | :-------------------------------- |
| begin;update Test set a=a+1 where id=1; | begin;                            |
|                                         | update Test set a=a+1 where id=2; |
| update Test set a=a+1 where id=2;       |                                   |
|                                         | update Test set a=a+1 where id=1; |

 事务A在等待事务B释放id=2的行锁，事务B在等待A释放id=1的行锁，事务A和事务B互相等待对方释放资源，于是进入了死锁状态。

> 插入不会主动加显示的X Record锁，只有检测到Key冲突的时候才会把隐式锁转为显式锁。
>
> 隐式锁你可以理解为乐观锁，也就是正常来说不加锁或共享锁，但是遇到冲突则加锁或升级为排它锁。显式锁，那就是真的锁上了。
>
> 限于篇幅原因，对这里有兴趣的同学可以阅读丁凎大神写的[Insert into 加锁机制](https://km.sankuai.com/page/58656969)，更进一步了解插入意向锁和间隙锁容易产生的死锁问题过程。

避免死锁有哪些方法？

- 以固定的顺序访问表和行。
- 大事务拆小。大事务更容易发生死锁，如果业务允许，将大事务拆小。
- 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁概率。
- 降低隔离级别。如果业务允许，将隔离级别调低也是较好的选择，比如将隔离级别从RR调整为RC，可以避免掉很多因为gap锁造成的死锁。
- 为表添加合理的索引。

**锁选择**

1）、如果更新条件没有走索引，例如执行”update from t1 set v2=0 where v2=5;” ，此时会进行全表扫描，扫表的时候，要阻止其他任何的更新操作，所以上升为表锁。

2）、如果更新条件为索引字段，但是并非唯一索引（包括主键索引），例如执行“update from t1 set v2=0 where v1=9;” 那么此时更新会使用Next-Key Lock。使用Next-Key Lock的原因：

a）、首先要保证在符合条件的记录上加上排他锁，会锁定当前非唯一索引和对应的主键索引的值；

b）、还要保证锁定的区间不能插入新的数据。

3）、如果更新条件为唯一索引，则使用Record Lock（记录锁）。

**加锁原则：**

加锁规则可以概括为：两个原则、两个优化和一个bug:

原则1:加锁的基本单位是next-key lock，前开后闭

原则2:查找过程中访问到的对象才会加锁

优化1:索引上的等值查询，给唯一索引加锁的时候，next-key lock退化成行锁

优化2:索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock退化为间隙锁

> 若在表ta的列a上有非唯一索引：index_a,该索引中存在的值为：1，1，3，3，7，9：当你执行select a from ta where ta.a=5时，就会从3开始往右（后）遍历，此时对应的 是(3,7]但是由于该区间的最后一个值7不满足=5的条件，因此该next-key lock就退化为gap lock (3,7)。

1个bug:唯一索引上的范围查询会访问到不满足条件的第一个值为止。

案例：https://www.cnblogs.com/nedulee/p/11838682.html


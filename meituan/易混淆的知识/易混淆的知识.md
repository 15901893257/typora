# 易混淆的知识

## 1.并发与并行的区别

并发和并行的区别就是一个处理器同时处理多个任务和多个处理器或者是多核的处理器同时处理多个不同的任务。
前者是逻辑上的同时发生（simultaneous），而后者是物理上的同时发生．

来个比喻：并发和并行的区别就是一个人同时吃三个馒头和三个人同时吃三个馒头。

## 2.Java字节码

### 2.1 什么是字节码

Java之所以可以“一次编译，到处运行”，一是因为JVM针对各种操作系统、平台都进行了定制，二是因为无论在什么平台，都可以编译生成固定格式的字节码（.class文件）供JVM使用。在Java中一般是用javac命令编译源代码为字节码文件，一个.java文件从编译到运行的示例如图所示。

![150931164](/Users/dengquanliang/typora/meituan/易混淆的知识/易混淆的知识.assets/150931164.png)

### 2.2 字节码结构

![](%E6%98%93%E6%B7%B7%E6%B7%86%E7%9A%84%E7%9F%A5%E8%AF%86.assets/WX20200522-184844@2x.png)

## 3.同步&异步

### 3.1 同步&异步

同步和异步关注的是**消息通信机制**

同步：就是在发出一个**调用**时，在没有得到结果之前，该**调用**就不返回。但是一旦调用返回，就得到返回值了。**换句话说，就是由调用者主动等待这个调用的结果。**

异步：**调用**在发出之后**，**这个**调用**就直接返回了**，**所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用。

举个通俗的例子：
你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下"，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。
而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。

需要注意的是，异步并非完全友好，性能也未必就是最佳。例如程序写到一半时，被老板拉出去开会几分钟，回来写程序的思路接不上了，得想一会才能接上。这就是异步带来的开销。因此在日常工作中，需要具体问题具体分析。

### **3.2 阻塞非阻塞**

阻塞和非阻塞关注的是**程序在等待调用结果（消息，返回值）时的状态**，它是从**“我”**这个单进程角度来看待。阻塞是指调用**结果返回之前**，当前进程**会被挂起**，只有当得到结果之后才会返回。而非阻塞是指在不能立刻得到结果之前，该调用不会阻塞当前进程，即**可以干别的其他事情，但需隔段时间回来check一下**。

举例：

![image-20200721145017234](%E6%98%93%E6%B7%B7%E6%B7%86%E7%9A%84%E7%9F%A5%E8%AF%86.assets/image-20200721145017234.png)

概念总结

同步异步，阻塞非阻塞他们**针对的对象是不一样的**。对于调用者来说是阻塞跟非阻塞，被调用者是同步跟异步。

同步：A调用B，此时只有等B有结果了才返回。
 异步: A调用B，B立即返回，无须等待。当B处理完之后会通过通知或者回调函数的方式来告诉A结果。
 阻塞：A调用B，A会被被挂起，一直在等待B的结果，什么事都不能干。
 非阻塞：A调用B，自己用被挂起等待B的结果，可以去干其他的事情。

参考：https://juejin.im/post/5cb58010e51d456e4d4de729

## 4.RPC和HTTP

### 4.1 什么是RPC?

RPC（Remote Procedure Call）—远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。比如两个不同的服务 A、B 部署在两台不同的机器上，那么服务 A 如果想要调用服务 B 中的某个方法该怎么办呢？使用 HTTP请求 当然可以，但是可能会比较慢而且一些优化做的并不好。 RPC 的出现就是为了解决这个问题。

### 4.2 RPC原理

![image-20200721155531803](%E6%98%93%E6%B7%B7%E6%B7%86%E7%9A%84%E7%9F%A5%E8%AF%86.assets/image-20200721155531803.png)

1. 服务消费方（client）调用以本地调用方式调用服务；
2. client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；
3. client stub找到服务地址，并将消息发送到服务端；
4. server stub收到消息后进行解码；
5. server stub根据解码结果调用本地的服务；
6. 本地服务执行并将结果返回给server stub；
7. server stub将返回结果打包成消息并发送至消费方；
8. client stub接收到消息，并进行解码；
9. 服务消费方得到最终结果

### 4.3 RPC和HTTP的不同点

1.**传输协议**

RPC，可以基于TCP协议，也可以基于HTTP协议

HTTP，基于HTTP协议（在TCP协议之上进行封装）

**2.传输效率**

RPC，使用自定义的TCP协议，可以让请求报文体积更小，或者使用HTTP2协议，也可以很好的减少报文的体积，提高传输效率

HTTP，如果是基于HTTP1.1的协议，请求中会包含很多无用的内容，如果是基于HTTP2.0，那么简单的封装以下是可以作为一个RPC来使用的，这时标准RPC框架更多的是服务治理

**3.性能消耗，主要在于序列化和反序列化的耗时**

RPC，可以基于thrift实现高效的二进制传输

HTTP，大部分是通过json来实现的，字节大小和序列化耗时都比thrift要更消耗性能

**4.负载均衡**

RPC，基本都自带了负载均衡策略

HTTP，需要配置Nginx，HAProxy来实现

**服务治理（下游服务新增，重启，下线时如何不影响上游调用者）**

RPC，能做到自动通知，不影响上游

HTTP，需要事先通知，修改Nginx/HAProxy配置

**总结：**

  **RPC主要用于公司内部的服务调用，性能消耗低，传输效率高，服务治理方便。HTTP主要用于对外的异构环境，浏览器接口调用，APP接口调用，第三方接口调用等。**

**既然两种方式都可以实现远程调用，我们该如何选择呢？**

\- 速度来看，RPC要比http更快，虽然底层都是TCP，但是http协议的信息往往比较臃肿，不过可以采用gzip压缩。
\- 难度来看，RPC实现较为复杂，http相对比较简单
\- 灵活性来看，http更胜一筹，因为它不关心实现细节，跨平台、跨语言。

因此，两者都有不同的使用场景：

\- 如果对效率要求更高，并且开发过程使用统一的技术栈，那么用RPC还是不错的。
\- 如果需要更加灵活，跨语言、跨平台，显然http更合适

### 4.4 参考

https://www.cnblogs.com/111testing/p/11297037.html


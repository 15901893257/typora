# 消息队列

## 1.什么是消息队列

消息队列（Message Queue）是一种进程间通信或同一进程的不同线程间的通信方式，主要解决应用耦合、异步消息、流量削锋等问题。实现高性能、高可用、可伸缩和最终一致性架构。是大型分布式系统不可缺少的中间件。消息发布者只管把消息发布到 MQ 中而不用管谁来取，消息使用者只管从 MQ 中取消息而不管是谁发布的。这样发布者和使用者都不用知道对方的存在。

## 2.消息队列有哪些角色

如下图所示：

[![MQ 角色](%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.assets/01.png)](http://static2.iocoder.cn/images/MQ/2019_11_12/01.png)MQ 角色

- 生产者（Producer）：负责产生消息。
- 消费者（Consumer）：负责消费消息
- 消息代理（Message Broker）：负责**存储消息**和**转发消息**两件事情。其中，转发消息分为**推送**和**拉取**两种方式。
  - 拉取（Pull），是指 Consumer 主动从 Message Broker 获取消息
  - 推送（Push），是指 Message Broker 主动将 Consumer 感兴趣的消息推送给 Consumer 。

## 3.消息队列的应用场景

### 3.1 异步处理

传统模式下，如下图所示：[![传统模式](%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.assets/05.png)](http://static2.iocoder.cn/images/MQ/2019_11_12/05.png)传统模式

- A 系统需要

  串行、逐个、同步调用系统 B、C、D 。这其中会有很多问题：

  - 如果每个系统调用执行是 200ms ，那么这个逻辑就要执行 600ms ，非常慢。
  - 如果任一一个系统调用异常报错，那么整个逻辑就报错了。
  - 如果任一一个系统调用超时，那么整个逻辑就超时了。
  - …

引入消息队列后，如下图所示：[![新模式](%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.assets/06.png)](http://static2.iocoder.cn/images/MQ/2019_11_12/06.png)新模式

- 通过发送 3 条 MQ 消息，通过 Consumer 消费，从而

  异步、并行调用系统 B、C、D 。

  - 因为发送 MQ 消息是比较快的，假设每个操作 2 ms ，那么这个逻辑只要执行 6 ms ，非常快。
  - 当然，有胖友会有，可能发送 MQ 消息会失败。当然，这个是会存在的，此时可以异步重试。当然，可能异步重试的过程中，JVM 进程挂了，此时又需要其他的机制来保证。不过，相比**串行**逐个**同步**调用系统 B、C、D 来说，出错的几率会低很多很多。

另外，使用消息队列进行异步处理，会有一个前提，返回的结果不依赖于处理的结果。

### 3.2 流量消峰

传统模式下，如下图所示：[![传统模式](%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.assets/07.png)](http://static2.iocoder.cn/images/MQ/2019_11_12/07.png)传统模式

- 对于大多数系统，一定会有访问量的波峰和波谷。比较明显的，就是我们经常使用的美团外卖，又或者被人诟病的小米秒杀。
- 如果在并发量大的时间，所有的请求直接打到数据库，造成数据库直接挂掉。

引入消息队列后，如下图所示：[![新模式](%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.assets/08.png)](http://static2.iocoder.cn/images/MQ/2019_11_12/08.png)新模式

- 通过将请求先转发到消息队列中。然后，系统 A 慢慢的按照数据库能处理的并发量，从消息队列中逐步拉取消息进行消费。在**生产中，这个短暂的高峰期积压是允许的**，😈 相比把数据库打挂来说。
- 当然，可能有胖友说，访问量这么大，不会把消息队列给打挂么？相比来说，消息队列的性能会比数据库性能更好，并且，横向的扩展能力更强。

### 3.3 应用解耦

当系统A中在订单创建后，需要通知B系统和C系统，然后B系统和C系统再做出相应的处理

![](%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.assets/WX20200601-171602@2x.png)

此时A系统是强依赖B系统和C系统，当B系统需要下线，或者需要重新加入D系统，则需要需改代码：

![](%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.assets/WX20200601-171638@2x.png)

如此这样反复的添加和删除依赖的系统，使得系统难以维护，此时可以通过MQ来进行解耦

![](%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.assets/WX20200601-171649@2x.png)

这个时候A系统就与需要关心订单创建事件的系统解耦开，不再关心下游有哪些系统，也不用受下游系统可用性的影响。

## 4.消息队列协议

### 4.1 AMQP

AMQP即Advanced Message Queuing Protocol，是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。它是具有现代特征的二进制协议: 多通道的、协商的、异步的、安全的、便携的、自然的、高效的。 

**AMQP(0.9.1)**通常划分成两层:

![image-20200601172532181](%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.assets/image-20200601172532181.png)

功能层（Functional Layer）定义了一系列命令，分成功能独立的逻辑类，可为应用程序做有用工作。

传输层（Transport Layer）将这些方法从应用程序应用搬到服务器并返回，它同时会处理通道复用、帧同步、内容编码、心跳检测以及数据表示和错误处理。

**AMQP 0.10**变化较大，分为3层：

![image-20200601172645969](%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.assets/image-20200601172645969.png)

模型层（Model）定义了一套命令，按功能分类，客户端应用可以利用这些命令来实现它的业务功能。

会话层（Session）负责将命令从客户端应用传递给服务器，再将服务器的应答传递给客户端应用，会话层为这个传递过程提供可靠性、同步机制和错误处理。

传输层（Transport）提供帧处理、信道复用、错误检测和数据表示。

AMQP 0.10在灵活度增加的同时复杂度也增加了。

**AMQP模型**

表示关键实体和语义的逻辑框架，它必须对兼容AMQP实现的服务器可用， 使得服务器的状态可以通过客户端按本规范中定义的语义来实现。

![image-20200601172745261](%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.assets/image-20200601172745261.png)

消息（Message）被发布者（Publisher）发送给交换机（Exchange），交换机常常被比喻成邮局或者邮箱。交换机将收到的消息按照路由规则分发到绑定的队列（Queue）中，最后AMQP代理会将消息投递给订阅了此队列的消费者（Consumer），或者消费者（Consumer）按需获取。



**协议特点：**面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全

### 4.2 MQTT

MQTT即Message Queuing Telemetry Transport，**消息队列遥测传输**，是IBM开发的一个即时通讯协议，是一种基于轻量级代理的，发布/订阅模式的消息传输协议，运行在TCP协议栈之上，为其提供有序、可靠、双向连接的网络连接保证。该协议支持所有平台，几乎可以把所有联网物品和外部连接起来，被用来当做传感器和致动器（比如通过APP让房屋联网）的通信协议。

![image-20200601172923212](%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.assets/image-20200601172923212.png)

MQTT协议工作在低带宽、不可靠的网络的远程传感器和控制设备通讯而设计的协议，它具有以下主要的几项特性：

- 使用发布/订阅消息模式，提供一对多的消息发布，解除应用程序耦合。
- 对负载内容屏蔽的消息传输。
- 使用TCP/IP提供网络连接。 主流的MQTT是基于TCP连接进行数据推送的，但是同样有基于UDP的版本，叫做MQTT-SN。这两种版本由于基于不同的连接方式，优缺点各有不同。
- 支持三种消息发布方式： 
  - 至多一次，消息发布完全依赖底层TCP/IP网络，会发生消息丢失或重复。这一级别可用于如下情况，环境传感器数据，丢失一次读记录无所谓，因为不久后还会有第二次发送。这一种方式主要普通APP的推送，倘若你的智能设备在消息推送时未联网，推送过去没收到，再次联网也就收不到了。 
  - 至少一次，确保消息到达，但消息重复可能会发生。 
  - 只有一次，确保消息到达一次。在一些要求比较严格的计费系统中，可以使用此级别。在计费系统中，消息重复或丢失会导致不正确的结果。这种最高质量的消息发布服务还可以用于即时通讯类的APP的推送，确保用户收到且只会收到一次。
- 小型传输，开销很小（固定长度的头部是2字节），协议交换最小化，以降低网络流量。 这就是为什么说它非常适合“物联网领域、传感器与服务器的通信、信息的收集“，要知道嵌入式设备的运算能力和带宽都相对薄弱，使用这种协议来传递消息再适合不过了。
- 使用Last Will（遗言机制）和Testament（遗嘱机制）特性处理相关客户端异常中断。

**协议特点：**格式简洁、占用带宽小、移动端通信、PUSH、嵌入式系统

### 4.3 STOMP

STOMP（Streaming Text Orientated Message Protocol）是流文本定向消息协议，是一种为MOM(Message Oriented Middleware，面向消息的中间件)设计的简单文本协议。STOMP提供一个可互操作的连接格式，允许客户端与任意STOMP消息代理（Broker）进行交互。

**Topic：**即消息队列 MQ 的消息主题，一级消息类型，通过 Topic 对消息进行分类以及权限管理

**Destination：**STOMP 协议里面的消息目的地，形式如 “/t/t1”，其中一级字符串 “t” 即为 Topic

**Instance ID：**消息队列 MQ 的实例 

**Client ID：**发送端或订阅端的唯一标识，便于日志查询

**协议特点:** 命令模式（非topic\queue模式）

### 4.4 XMPP

XMPP（可扩展消息处理现场协议，Extensible Messaging and Presence Protocol）是基于可扩展标记语言（XML）的协议，多用于即时消息（IM）以及在线现场探测，适用于服务器之间的准即时操作。核心是基于XML流传输，这个协议可能最终允许因特网用户向因特网上的其他任何人发送即时消息，即使其操作系统和浏览器不同。

**协议特点**：通用公开、兼容性强、可扩展、安全性高，但XML编码格式占用带宽大

## 5.常用消息队列介绍

### 5.1 RabbitMQ

RabbitMQ是实现**AMQP协议(0.9.1)**的消息中间件的一种，由RabbitMQ Technologies Ltd开发并且提供商业支持的，最初起源于金融系统，服务器端用Erlang语言编写，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。 

![](%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.assets/WX20200601-173447@2x.png)

**组成元素**

- 元素包括：Producer（生产者）、Consumer（消费者）、Broker（代理服务器）、Virtual Host（虚拟节点）、Exchange（交换机）、Message（消息）、Queue（队列）
- 一个Broker中一定包含完整的Virtual Host、 Exchange、Queue定义，一个Broker可以创建多个Virtual Host，如果是由多个Broker构成的集群提供服务，那么一个Virtual Host也可以由多个Broker共同构成。
- Producer生产消息，将消息发送给Broker。Consumer消费消息，负责从broker处获取消息。
- Connection是由Producer和Consumer创建的连接，连接到Broker物理节点上。但是有了Connection后客户端还不能和服务器通信，在Connection之上客户端会创建Channel，连接到Virtual Host或者Queue上，这样客户端才能向Exchange发送消息或者从Queue接受消息。一个Connection上允许存在多个Channel，只有Channel中能够发送/接受消息。
- Exchange可以绑定多个Queue也可以同时绑定其他Exchange。消息通过Exchange时，会按照Exchange中设置的Routing规则，将消息发送到符合的Queue或者Exchange中。

**消息路由**

![image-20200601173528498](%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.assets/image-20200601173528498.png)

1. Producer会先建立Channel，建立到Broker上Virtual Host的连接，接下来就可以向这个Virtual Host中的Exchange发送消息。
2. Producer把消息发布到Exchange上，消息最终到达队列并被消费者接收，而Binding决定交换器的消息应该发送到那个队列。Exchange能够处理消息的前提是，它至少已经和某个Queue或者另外的Exchange形成了绑定关系，并设置好了到这些Queue和Excahnge的路由规则。在Exchange收到消息后，会根据设置的路由规则，将消息发送到符合要求的Queue或者Exchange中（路由规则与Message中的Routing Key属性配合使用）。
3. 当Queue收到消息后，会进行如下处理：
   1. 如果当前没有Consumer的Channel连接到这个Queue，那么Queue将会把这条消息进行存储，直到有Channel被创建。
   2. 如果已经有Channel连接到这个Queue，那么消息将会按顺序发送给这个Channel。
4. 当Consumer收到消息后，就可以进行消息的处理：
   1. Consumer在完成某一条消息的处理后，将需要手动的发送一条ACK消息到对应的Queue，也可以设置为自动发送或者无需发送。
   2. Queue在接收到这条ACK信息后，才认为这条消息处理成功，并将这条消息从Queue中移除。
   3. 如果在对应的Channel断开后，Queue都没有这条消息的ACK信息，这条消息将会重新被发送给另外的Channel。也可以直接发送NACK信息，这样这条消息将会立即归队，并发送给另外的Channel。

**Exchange类型**

Exchange分发消息时，根据类型的不同，分发策略有明显的区别，目前共四种类型：Direct、Fanout、Topic、Headers。Headers匹配AMQP消息的Header而不是路由键，此外Headers交换器和Direct交换器完全一致，但性能差很多，目前几乎不用，这里直接介绍另外三种类型：

- **DIRECT**

消息中的路由键（Routing Key）如果和Binding中的Binding Key一致，交换器就将消息发到对应的队列中。路由键与队列名完全匹配，如果一个队列绑定到交换机要求路由键为news，则只转发Routing Key为news的消息，不会转发weather，它是完全匹配、单播的模式。

- **FANOUT**

每个发到Fanout类型交换器的消息都会分到所有绑定的队列上去。Fanout交换器不处理路由键，只是简单的将队列绑定到交换器上，每个发送到交换器的消息都会被转发到与该交换器绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份消息的复制。Fanout 类型转发消息是最快的。

- **TOPIC**

交换器通过模式匹配分配消息的路由键属性，将路由键和某个模式进行匹配，此时队列需要绑定到一个模式上。它将路由键和绑定键的字符串切分成单词，这些单词之间用点隔开。

支持通配符：

- *匹配一个单词
- \#匹配0个或多个单词

 **主要特性：**

1. **可靠性**：提供了多种技术可以让你在性能和可靠性之间进行权衡，如持久性机制、投递确认、发布确认和高可用性机制
2. **灵活的路由**：消息在到达队列之前，通过Exchange进行路由。对于典型的路由RabbitMQ提供了一些内置的Exchange，而对于更复杂的路由，则可以将这些Exchange组合起来使用，甚至可以实现自己的Exchange，并且当做 RabbitMQ的插件来使用
3. **消息集群**：在相同局域网中的多个 RabbitMQ 服务器聚合在一起，形成一个逻辑 Broker
4. **高可用**：队列可以在集群中的机器上进行镜像，以确保在硬件问题下还保证消息安全
5. **多协议**：支持多种消息队列协议, 如 STOMP、MQTT等
6. **多语言**：使用Erlang语言编写，客户端几乎支持所有常用语言
7. **管理界面**： RabbitMQ有一个易用的web用户界面，使得用户可以方便的进行监控和消息的管理
8. **跟踪机制**：RabbitMQ提供消息跟踪机制
9. **插件机制**：提供了许多的插件来进行扩展，也支持自定义插件的开发

### 5.2 kafka

Kafka是由Apache软件基金会开发的一个开源流处理平台，由Scala和Java编写。Kafka是一种高吞吐量的分布式发布订阅消息系统，它可以处理消费者规模的网站中的所有动作流数据。 这种动作（网页浏览，搜索和其他用户的行动）是在现代网络上的许多社会功能的一个关键因素。 这些数据通常是由于吞吐量的要求而通过处理日志和日志聚合来解决。 对于像Hadoop的一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。Kafka的目的是通过Hadoop的并行加载机制来统一线上和离线的消息处理，也是为了通过集群来提供实时的消息。

![image-20200601175101445](%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.assets/image-20200601175101445.png)

**基本组件：**

- **Broker**
  消息中间件处理节点，一个Kafka节点就是一个Broker，一个或者多个Broker可以组成一个Kafka集群

- **Topic**
  每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic。（物理上不同Topic的消息分开存储，逻辑上一个Topic的消息虽然保存于一个或多个broker上但用户只需指定消息的Topic即可生产或消费数据而不必关心数据存于何处）

- **Partition**
  用于存放消息的队列，存放的消息都是有序的，同一主题可以分多个Partition，如分多个Partiton时，同样会以如partition1存放1、3、5消息，partition2存放2、4、6消息

- **Producer**
  消息生产者，向Broker发送消息的客户端

- **Consumer**
  消息消费者，从Broker读取消息的客户端，Consumer是通过offset进行标识消息被消费的位置

- **Consumer Group**
  每个Consumer属于一个特定的Consumer Group，一条消息可以发送到多个不同的Consumer Group，但是同一个Consumer Group中只能有一个Consumer能够消费该消息

  

**主要特性：**

1. **快速持久化**：可以在 O(1) 的系统开销下进行消息持久化
2. **高吞吐**：在一台普通的服务器上既可以达到10W/s的吞吐速率
3. **完全的分布式系统**：Broker、Producer和Consumer都原生自动支持分布式，自动实现负载均衡
4. **零拷贝技术(zero-copy)**：减少IO操作步骤，提高系统吞吐量
5. 支持同步和异步复制两种高可用机制
6. 丰富的消息拉取模型，支持数据批量发送和拉取
7. 数据迁移、扩容对用户透明
8. 无需停机即可扩展机器
9. 高效订阅者水平扩展、实时的消息订阅、亿级的消息堆积能力、定期删除机制

## 6. 消息队列对比

| **特性**                | **RabbitMQ**                                                 | **RocketMQ**                                                 | **Kafka**                                                    | **ActiveMQ**                           |
| :---------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :------------------------------------- |
| 开发语言                | Erlang                                                       | Java                                                         | Scala&Java                                                   | Java                                   |
| 客户端支持              | 官方支持Erlang、Java、Ruby等，社区产出多语言API，几乎支持所有常用语言 | Java、C++                                                    | 官方支持Java，社区有多语言版本，如PHP、Python、Go、C/C++、Ruby、NodeJs等 | Java、C/C++、Python、PHP、Perl、.net等 |
| 协议支持                | AMQP、XMPP、SMTP、SMTOP                                      | 自定义协议，社区提供JMS                                      | 自定义协议，社区提供了HTTP协议支持                           | OpenWire、SMTOP、REST、XMPP、AMQP      |
| 可用性                  | 高，基于主从架构实现高可用                                   | 很高，分布式架构                                             | 很高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用 | 高，基于主从架构实现高可用             |
| 集群                    | 支持                                                         | 支持                                                         | 支持                                                         | 支持                                   |
| 负载均衡                | 支持                                                         | 支持                                                         | 支持                                                         | 支持                                   |
| 单机吞吐量              | 万级                                                         | 十万级                                                       | 十万级                                                       | 万级                                   |
| topic数量对吞吐量的影响 | -                                                            | topic达到几百/几千的级别后，吞吐量会有较小幅度的下降，在同等机器下，可以支撑大量的 topic | topic从几十到几百个时候，吞吐量会大幅度下降，因为Kafka的每个Topic、每个分区都会对应一个物理文件，若需要支撑大规模的topic，则需要增加更多的机器资源 | -                                      |
| 消息批量操作            | 不支持                                                       | 支持                                                         | 支持                                                         | 支持                                   |
| 消息推拉模式            | pull/push均支持                                              | pull/push均支持                                              | pull                                                         | pull/push均支持                        |
| 消息可靠性              | 可以做到不丢失                                               | 可以做到不丢失                                               | 可以做到不丢失                                               | 有较低的概率丢失数据                   |
| 消息延迟                | 微秒级 (最快)                                                | 毫秒级                                                       | 毫秒级                                                       | 毫秒级                                 |
| 持久化能力              | 内存、文件，支持数据堆积，但影响生产速率                     | 磁盘文件                                                     | 磁盘文件，只要容量够，可以做到无限堆积                       | 内存、文件、数据库                     |
| 事务消息                | 不支持                                                       | 支持                                                         | 不支持                                                       | 支持                                   |
| 管理界面                | web管理界面                                                  | web管理界面                                                  | web管理界面                                                  | web管理界面                            |

## 7.消息队列的一般存储方式

🦅 **1. 分布式KV存储**

这类 MQ 一般会采用诸如 LevelDB 、RocksDB 和 Redis 来作为消息持久化的方式。由于分布式缓存的读写能力要优于 DB ，所以在对消息的读写能力要求都不是比较高的情况下，采用这种方式倒也不失为一种可以替代的设计方案。

消息存储于分布式 KV 需要解决的问题在于如何保证 MQ 整体的可靠性。

🦅 **2. 文件系统**

目前业界较为常用的几款产品（RocketMQ / Kafka / RabbitMQ）均采用的是消息刷盘至所部署虚拟机/物理机的文件系统来做持久化（刷盘一般可以分为异步刷盘和同步刷盘两种模式）。

> 刷盘指的是存储到硬盘。

消息刷盘为消息存储提供了一种高效率、高可靠性和高性能的数据持久化方式。除非部署 MQ 机器本身或是本地磁盘挂了，否则一般是不会出现无法持久化的故障问题。

🦅 **3. 关系型数据库 DB**